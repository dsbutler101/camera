#!/usr/bin/env python3

import colorsys
import time
import numpy as np
from sys import exit
import subprocess
import os, sys, socket, re, json
from threading import Thread
from queue import Queue
from time import time, sleep
from os.path import isfile, basename
from google.cloud import storage
from google.cloud import pubsub_v1
from blinkt import set_clear_on_exit, set_pixel, show, set_brightness
from PIL import Image
from PIL import ImageStat

BUCKET_NAME = os.environ['BUCKET_NAME']
IMAGE_PATH = "/home/pi/images/"
USERNAME = os.environ['USERNAME']
SERVICE_NAME = os.environ['SERVICE_NAME']
LOCK_FILE = os.path.expanduser("~") + "/IPHONE-AT-HOME"
LEAVE_DELAY = 500
HOSTS = os.environ["IPHONE_NAME"].split(',')
PROJECT_ID = os.environ['PROJECT_ID']
TOPIC_NAME = "events"
KEY_FILE = "/home/pi/key-file.json"


def make_gaussian(fwhm):
    x = np.arange(0, 8, 1, float)
    y = x[:, np.newaxis]
    x0, y0 = 3.5, 3.5
    fwhm = fwhm
    gauss = np.exp(-4 * np.log(2) * ((x - x0) ** 2 + (y - y0) ** 2) / fwhm ** 2)
    return gauss


def security_light():
   set_clear_on_exit()
   while True:
       for z in list(range(1, 10)[::-1]) + list(range(1, 10)):
           fwhm = 5.0/z
           gauss = make_gaussian(fwhm)
           start = time()
           y = 2
           for x in range(8):
               h = 0.0
               s = 1.0
               v = gauss[x, y]
               rgb = colorsys.hsv_to_rgb(h, s, v)
               r, g, b = [int(255.0 * i) for i in rgb]
               set_pixel(x, r, g, b)
           show()
           end = time()
           t = end - start
           if t < 0.02:
               sleep(0.02 - t)
       sleep(5)


def callback(message_future):
   # When timeout is unspecified, the exception method waits indefinitely.
   if message_future.exception(timeout = 30):
      print("Error publishing message: " + message_future.exception())
   else:
      print(message_future.result())


def upload_images():
   storage_client = storage.Client.from_service_account_json(KEY_FILE)
   bucket = storage_client.bucket(BUCKET_NAME)
   publisher = pubsub_v1.PublisherClient.from_service_account_json(KEY_FILE)
   topic_path = publisher.topic_path(PROJECT_ID, TOPIC_NAME)
   while True:
      files = os.listdir(IMAGE_PATH)
      files.sort(reverse = True)
      for f in files[1000:]:
         print("Deleting file to preserve disk space: " + f)
         try:
            os.remove(IMAGE_PATH + f)
         except Exception as e:
            print("Error, unable to delete file: " + f + " error: " + str(e))
      message = []
      phone_at_home = isfile(LOCK_FILE)
      files_to_delete = []
      for f in reversed(files[:100]):
         p = f.split("-") 
         if len(p) != 16:
            print("Invalid filename, deleting: " + f)
            os.remove(IMAGE_PATH + f)
            continue
         try:
            image = Image.open(IMAGE_PATH + f).convert('L')
            stat = ImageStat.Stat(image)
            brightness = stat.mean[0]
            event = {
               "event_time" : "{}-{}-{}T{}:{}:{}.000000Z".format(*p),
               "camera_id" : p[6],
               "event" : p[7],
               "frame" : p[8],
               "pixels_changed" : p[9],
               "noise" : p[10],
               "area_height" : p[11],
               "area_width" : p[12],
               "area_x" : p[13],
               "area_y" : p[14],
               "user_email" : USERNAME,
               "camera_name" : SERVICE_NAME,
               "phone_at_home" : phone_at_home,
               "brightness": brightness
            }
            if "picture" in p[15]:
               print("Uploading image file: " + IMAGE_PATH + f)
               name =  USERNAME + "/" + SERVICE_NAME + "/" + str(phone_at_home) + "/" + f
               blob = storage.blob.Blob(name, bucket)
               with open(IMAGE_PATH + f, "rb") as file_obj:
                  blob.upload_from_file(file_obj, rewind = True)
               print("Image uploaded successfully.")
               event['file_object'] = "gs://" + BUCKET_NAME + "/" + name
            print("Appending event to message for image: " + f)
            message.append(event)
            files_to_delete.append(f)
         except Exception as e:
            print("Error uploading file: " + str(e))
      if len(message) > 0:
         data = json.dumps(message).encode('utf-8')
         print("Publishing message of {} events".format(len(message)))
         try:
            message_future = publisher.publish(topic_path, data = data)
            message_future.add_done_callback(callback)
            for f in files_to_delete:
               os.remove(IMAGE_PATH + f)
            print("Message sent and files removed")
         except Exception as e:
            print("Error sending message: " + str(e))
      sleep(0.5)


def remove_lockfile():
   try:
      os.remove(LOCK_FILE)
   except:
      pass


def ping(q):
   global last_seen
   while True:
      host = q.get()
      response = subprocess.call(
         "ping -c 1 -t 1 " + host,
         shell = True,
         stdout = open('/dev/null', 'w'),
         stderr = subprocess.STDOUT
      )
      if response == 0:
         last_seen = time()


def detect_iphone():
   global last_seen
   q = Queue()
   home = False
   remove_lockfile()
   for host in HOSTS:
      Thread(target = ping, args=(q,)).start()
   while True:
      for host in HOSTS:
         q.put(host)
      t = time()
      if (t - last_seen) > LEAVE_DELAY:
         if home:
            print("EVENT: Device gone away " + str(t))
            remove_lockfile()
         home = False
      else:
         if not home:
            print("EVENT: Device returned home " + str(t))
            open(LOCK_FILE, 'a').close()
         home = True
      if q.qsize() > 4:
         sleep(3.0)
      sleep(1.0)


if __name__ == '__main__':
   last_seen = 0.0
   Thread(target = detect_iphone).start()
   Thread(target = security_light).start()
   upload_images()
